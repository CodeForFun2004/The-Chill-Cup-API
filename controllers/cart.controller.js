const Cart = require('../models/cart.model');
const CartItem = require('../models/cartItem.model');
const Product = require('../models/product.model');
const Topping = require('../models/topping.model');
const Discount = require('../models/discount.model');
const UserDiscount = require('../models/userDiscount.model');

const DELIVERY_FEE = 10000;

// const calculateCartTotals = async (cartItemIds) => {
//   const items = await CartItem.find({ _id: { $in: cartItemIds } })
//     .populate('productId')
//     .populate('toppings');

//   let subtotal = 0;
//   const result = [];

//   for (const item of items) {
//     const product = item.productId;
//     const multiplier = item.size === 'S' ? 0.8 : item.size === 'L' ? 1.3 : 1.0;
//     const basePrice = product.basePrice * multiplier;
//     const toppingCost = item.toppings.reduce((sum, t) => sum + t.price, 0);
//     const itemTotal = (basePrice + toppingCost) * item.quantity;

//     subtotal += itemTotal;

//     result.push({
//       _id: item._id,
//       name: product.name,
//       image: product.image,
//       size: item.size,
//       quantity: item.quantity,
//       toppings: item.toppings,
//       unitPrice: basePrice + toppingCost,
//       total: itemTotal
//     });
//   }

//   return { items: result, subtotal };
// };

// üü¢ Add item to cart (updated)
// exports.addToCart = async (req, res) => {
//   try {
//     const { productId, size, toppings = [], quantity } = req.body;
//     const userId = req.user._id;

//     const newItem = await CartItem.create({
//       userId, productId, size, toppings, quantity
//     });

//     let cart = await Cart.findOne({ userId });
//     if (!cart) {
//       cart = await Cart.create({ userId, cartItems: [newItem._id] });
//     } else {
//       cart.cartItems.push(newItem._id);
//     }

//     await cart.save();

//     // Populate full cartItems with product details
//     const populatedCart = await Cart.findById(cart._id)
//       .populate({
//         path: 'cartItems',
//         populate: {
//           path: 'productId',
//           populate: ['categoryId', 'sizeOptions', 'toppingOptions']
//         }
//       });

//     const { items, subtotal } = await calculateCartTotals(populatedCart.cartItems);
//     populatedCart.subtotal = subtotal;
//     populatedCart.total = subtotal + populatedCart.deliveryFee - populatedCart.discount;
//     await populatedCart.save();

//     res.status(201).json({
//       message: 'ƒê√£ th√™m v√†o gi·ªè h√†ng',
//       items,                   // array of detailed CartItem
//       subtotal,
//       deliveryFee: populatedCart.deliveryFee,
//       discount: populatedCart.discount,
//       total: populatedCart.total
//     });
//   } catch (err) {
//     console.error('[addToCart]', err);
//     res.status(500).json({ error: 'Kh√¥ng th·ªÉ th√™m v√†o gi·ªè h√†ng' });
//   }
// };


// üü° Get full cart
// exports.getCart = async (req, res) => {
//     try {
//       const cart = await Cart.findOne({ userId: req.user._id }).populate('cartItems');

//       console.log(cart)
//       console.log('Hello world')

//       if (!cart) {
//         return res.status(200).json({
//           items: [],
//           subtotal: 0,
//           deliveryFee: DELIVERY_FEE,
//           discount: 0,
//           total: 0
//         });
//       }
  
//       const { items, subtotal } = await calculateCartTotals(cart.cartItems);
//       cart.subtotal = subtotal;
//       cart.total = subtotal + cart.deliveryFee - cart.discount;
//       await cart.save();
  
//       res.status(200).json({
//         items,
//         subtotal,
//         deliveryFee: cart.deliveryFee,
//         discount: cart.discount,
//         total: cart.total
//       });
//     } catch (err) {
//       console.error('[getCart]', err);
//       res.status(500).json({ error: 'Kh√¥ng th·ªÉ l·∫•y gi·ªè h√†ng' });
//     }
//   };
  
// H√†m tr·ª£ gi√∫p ƒë·ªÉ t·∫°o s·ªë ƒë∆°n h√†ng duy nh·∫•t
function generateOrderNumber() {
    return `#ORD-${Math.random().toString(36).substring(2, 9)}`;
}

async function calculateCartTotals(cartItems) {
    let subtotal = 0;
    const itemsWithCalculatedPrice = [];

    for (const item of cartItems) {
        let itemPrice = 0;

        const product = await Product.findById(item.productId).populate('sizeOptions');
        if (!product) {
            console.warn(`Product with ID ${item.productId} not found for cart item.`);
            continue;
        }

        const sizeOption = product.sizeOptions.find(s => s.size === item.size);
        // T√≠nh to√°n gi√° d·ª±a tr√™n basePrice c·ªßa Product v√† multiplier c·ªßa Size
        if (sizeOption && typeof product.basePrice === 'number' && typeof sizeOption.multiplier === 'number') {
            itemPrice += product.basePrice * sizeOption.multiplier * item.quantity;
        } else {
            console.warn(`Size option ${item.size} not found or price/multiplier is invalid for product ${product.name}.`);
        }

        for (const toppingId of item.toppings) {
            const topping = await Topping.findById(toppingId);
            if (topping && typeof topping.price === 'number') {
                itemPrice += topping.price * item.quantity;
            } else {
                console.warn(`Topping with ID ${toppingId} not found or price is invalid. Skipping this topping.`);
            }
        }

        itemsWithCalculatedPrice.push({
            ...item.toObject(),
            price: itemPrice,
            productId: product
        });
        subtotal += itemPrice;
    }

    return { items: itemsWithCalculatedPrice, subtotal };
}


exports.addToCart = async (req, res) => {
    try {
        const { productId, size, toppings = [], quantity } = req.body;
        const userId = req.user._id;

        const product = await Product.findById(productId).populate('sizeOptions');
        if (!product) {
            return res.status(404).json({ error: 'S·∫£n ph·∫©m kh√¥ng t·ªìn t·∫°i.' });
        }

        let itemPrice = 0;
        const sizeOption = product.sizeOptions.find(s => s.size === size);
        console.log(`Size option for ${size}:`, sizeOption);

        // C·∫≠p nh·∫≠t logic t√≠nh to√°n gi√°: basePrice * multiplier * quantity
        if (sizeOption && typeof product.basePrice === 'number' && typeof sizeOption.multiplier === 'number') {
            itemPrice += product.basePrice * sizeOption.multiplier * quantity;
        } else {
            return res.status(400).json({ error: `K√≠ch th∆∞·ªõc ${size} kh√¥ng h·ª£p l·ªá ho·∫∑c gi√° c∆° b·∫£n/h·ªá s·ªë nh√¢n kh√¥ng x√°c ƒë·ªãnh cho s·∫£n ph·∫©m n√†y.` });
        }

        const populatedToppings = [];
        for (const toppingId of toppings) {
            const topping = await Topping.findById(toppingId);
            if (topping && typeof topping.price === 'number') {
                itemPrice += topping.price * quantity;
                populatedToppings.push(topping);
            } else {
                console.warn(`Topping with ID ${toppingId} not found or price is invalid. Skipping this topping.`);
            }
        }

        const newItem = await CartItem.create({
            userId,
            productId,
            size,
            toppings,
            quantity,
            price: itemPrice
        });

        let cart = await Cart.findOne({ userId });
        if (!cart) {
            cart = await Cart.create({ userId, cartItems: [newItem._id] });
        } else {
            cart.cartItems.push(newItem._id);
        }
        await cart.save();

        const populatedCart = await Cart.findById(cart._id)
            .populate({
                path: 'cartItems',
                populate: [
                    {
                        path: 'productId',
                        model: 'Product',
                        populate: ['categoryId', { path: 'sizeOptions', model: 'Size' }, 'toppingOptions']
                    },
                    {
                        path: 'toppings',
                        model: 'Topping'
                    }
                ]
            });

        let subtotal = 0;
        const itemsForResponse = populatedCart.cartItems.map(item => {
            subtotal += item.price;
            return {
                _id: item._id,
                productId: item.productId,
                name: item.productId.name,
                size: item.size,
                toppings: item.toppings,
                quantity: item.quantity,
                price: item.price
            };
        });

        populatedCart.subtotal = subtotal;
        populatedCart.total = subtotal + populatedCart.deliveryFee - populatedCart.discount;
        await populatedCart.save();

        res.status(201).json({
            message: 'ƒê√£ th√™m v√†o gi·ªè h√†ng',
            items: itemsForResponse,
            subtotal: populatedCart.subtotal,
            deliveryFee: populatedCart.deliveryFee,
            discount: populatedCart.discount,
            total: populatedCart.total
        });
    } catch (err) {
        console.error('[addToCart]', err);
        res.status(500).json({ error: 'Kh√¥ng th·ªÉ th√™m v√†o gi·ªè h√†ng' });
    }
};

exports.getCart = async (req, res) => {
  try {
    const cart = await Cart.findOne({ userId: req.user._id }).populate('cartItems');

    // console.log(cart) // ƒê·ªÉ l·∫°i console.log ƒë·ªÉ debug n·∫øu c·∫ßn
    // console.log('Hello world') // C√≥ th·ªÉ x√≥a d√≤ng n√†y

    if (!cart) {
      return res.status(200).json({
        items: [],
        subtotal: 0,
        deliveryFee: DELIVERY_FEE,
        discount: 0,
        total: 0,
        promoCode: '' // ‚úÖ TR·∫¢ V·ªÄ promoCode m·∫∑c ƒë·ªãnh khi gi·ªè h√†ng r·ªóng
      });
    }

    const { items, subtotal } = await calculateCartTotals(cart.cartItems);
    
    // C·∫≠p nh·∫≠t gi·ªè h√†ng v·ªõi subtotal m·ªõi v√† t√≠nh l·∫°i total.
    // ƒêi·ªÅu n√†y l√† quan tr·ªçng ƒë·ªÉ ƒë·∫£m b·∫£o d·ªØ li·ªáu lu√¥n ƒë∆∞·ª£c t√≠nh to√°n l·∫°i ch√≠nh x√°c
    // m·ªói khi gi·ªè h√†ng ƒë∆∞·ª£c truy xu·∫•t, ƒë·∫∑c bi·ªát n·∫øu gi√° s·∫£n ph·∫©m ho·∫∑c s·ªë l∆∞·ª£ng thay ƒë·ªïi
    // m√† kh√¥ng th√¥ng qua API c·∫≠p nh·∫≠t gi·ªè h√†ng tr·ª±c ti·∫øp.
    cart.subtotal = subtotal;
    // ƒê·∫£m b·∫£o total ƒë∆∞·ª£c t√≠nh ƒë√∫ng: subtotal + deliveryFee - discount
    cart.total = subtotal + cart.deliveryFee - cart.discount; 
    
    await cart.save(); // L∆∞u l·∫°i c√°c c·∫≠p nh·∫≠t subtotal v√† total

    res.status(200).json({
      items,
      subtotal,
      deliveryFee: cart.deliveryFee,
      discount: cart.discount,
      total: cart.total,
      promoCode: cart.promoCode || '' // ‚úÖ TR·∫¢ V·ªÄ promoCode t·ª´ gi·ªè h√†ng
    });
  } catch (err) {
    console.error('[getCart]', err);
    res.status(500).json({ error: 'Kh√¥ng th·ªÉ l·∫•y gi·ªè h√†ng' });
  }
};



// üü† Remove 1 CartItem
exports.removeCartItem = async (req, res) => {
  try {
    const userId = req.user._id;
    const cart = await Cart.findOne({ userId });
    if (!cart) return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y gi·ªè h√†ng' });

    cart.cartItems = cart.cartItems.filter(itemId => itemId.toString() !== req.params.itemId);
    await CartItem.findByIdAndDelete(req.params.itemId);

    const { subtotal } = await calculateCartTotals(cart.cartItems);
    cart.subtotal = subtotal;
    cart.total = subtotal + cart.deliveryFee - cart.discount;
    await cart.save();

    res.status(200).json({ message: 'ƒê√£ xo√° s·∫£n ph·∫©m', cart });
  } catch (err) {
    res.status(500).json({ error: 'Kh√¥ng th·ªÉ xo√° s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng' });
  }
};


exports.clearCart = async (req, res) => {
  try {
    const userId = req.user._id;

    const cart = await Cart.findOne({ userId });

    if (!cart) {
      return res.status(200).json({
        message: 'Gi·ªè h√†ng ƒë√£ tr·ªëng.',
        items: [],
        subtotal: 0,
        discount: 0,
        total: 0,
        deliveryFee: DELIVERY_FEE, // S·ª≠ d·ª•ng h·∫±ng s·ªë
        taxRate: 0.01,
        promoCode: '' // ƒê·∫£m b·∫£o tr·∫£ v·ªÅ promoCode r·ªóng
      });
    }

    // --- X·ª≠ l√Ω UserDiscount v√† m√£ gi·∫£m gi√° ƒë√£ √°p d·ª•ng ---
    if (cart.promoCode) { // ‚úÖ S·ª¨ D·ª§NG cart.promoCode t·ª´ Cart model
      const discount = await Discount.findOne({ promotionCode: cart.promoCode });

      if (discount) {
        const userDiscountUpdateResult = await UserDiscount.updateOne(
          { userId: userId, discountId: discount._id, isUsed: true },
          { $set: { isUsed: false } }
        );

        if (userDiscountUpdateResult.modifiedCount > 0) {
          console.log(`UserDiscount for user ${userId} and discount ${discount._id} was successfully reset to isUsed: false.`);
        } else {
          console.log(`UserDiscount for user ${userId} and discount ${discount._id} not found or already reset (isUsed: false).`);
        }
      } else {
          console.log(`Discount not found for promoCode: ${cart.promoCode}. Cannot reset UserDiscount.`);
      }
      // Sau khi x·ª≠ l√Ω UserDiscount, ƒë·∫£m b·∫£o x√≥a promoCode kh·ªèi gi·ªè h√†ng
      cart.promoCode = ''; // ‚úÖ Reset promoCode trong cart v·ªÅ r·ªóng
      await cart.save(); // L∆∞u thay ƒë·ªïi cho cart
    }

    // --- X√≥a t·∫•t c·∫£ CartItem t∆∞∆°ng ·ª©ng trong collection CartItem ---
    if (cart.cartItems && cart.cartItems.length > 0) {
      await CartItem.deleteMany({ _id: { $in: cart.cartItems } });
      console.log(`Deleted ${cart.cartItems.length} CartItems for cart ${cart._id}.`);
    }

    // --- X√≥a gi·ªè h√†ng ch√≠nh kh·ªèi database ---
    await Cart.deleteOne({ userId });
    console.log(`Cart for user ${userId} was deleted.`);

    // Tr·∫£ v·ªÅ m·ªôt ƒë·ªëi t∆∞·ª£ng gi·ªè h√†ng tr·ªëng kh·ªõp v·ªõi CartApiResponse c·ªßa frontend
    res.status(200).json({
      message: 'Gi·ªè h√†ng ƒë√£ ƒë∆∞·ª£c x√≥a v√† m√£ gi·∫£m gi√° ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t l·∫°i.',
      items: [],
      subtotal: 0,
      discount: 0,
      total: 0,
      deliveryFee: DELIVERY_FEE, // S·ª≠ d·ª•ng h·∫±ng s·ªë
      taxRate: 0.01,
      promoCode: '' // ƒê·∫£m b·∫£o tr·∫£ v·ªÅ promoCode r·ªóng
    });

  } catch (err) {
    console.error('[Clear Cart Error]', err);
    res.status(500).json({ error: 'Kh√¥ng th·ªÉ x√≥a gi·ªè h√†ng: ' + err.message });
  }
};



// ‚úÖ √Åp d·ª•ng m√£ gi·∫£m gi√° v√†o gi·ªè h√†ng
exports.applyDiscountToCart = async (req, res) => {
  try {
    const { promotionCode } = req.body;
    const userId = req.user._id;

    // 1. T√¨m gi·ªè h√†ng v√† populate cartItems
    const cart = await Cart.findOne({ userId }).populate('cartItems');
    if (!cart) return res.status(400).json({ error: 'Kh√¥ng t√¨m th·∫•y gi·ªè h√†ng' });

    // 2. T√¨m m√£ gi·∫£m gi√°
    const discount = await Discount.findOne({ promotionCode });
    if (!discount) return res.status(404).json({ error: 'M√£ gi·∫£m gi√° kh√¥ng h·ª£p l·ªá' });

    // 3. Ki·ªÉm tra ƒëi·ªÅu ki·ªán m√£ gi·∫£m gi√°
    if (discount.isLock) return res.status(400).json({ error: 'M√£ gi·∫£m gi√° ƒë√£ b·ªã kho√°' });
    if (discount.expiryDate < new Date()) return res.status(400).json({ error: 'M√£ gi·∫£m gi√° ƒë√£ h·∫øt h·∫°n' });

    // 4. Ki·ªÉm tra UserDiscount (ng∆∞·ªùi d√πng ƒë√£ s·ª≠ d·ª•ng m√£ n√†y ch∆∞a)
    const userDiscount = await UserDiscount.findOne({ userId, discountId: discount._id });
    if (userDiscount?.isUsed) return res.status(400).json({ error: 'B·∫°n ƒë√£ s·ª≠ d·ª•ng m√£ n√†y' });

    // 5. T√≠nh subtotal hi·ªán t·∫°i c·ªßa gi·ªè h√†ng
    // ƒê·∫£m b·∫£o calculateCartTotals lu√¥n tr·∫£ v·ªÅ { items, subtotal }
    const { items: currentCartItems, subtotal: currentSubtotal } = await calculateCartTotals(cart.cartItems);

    if (currentSubtotal < discount.minOrder) {
      return res.status(400).json({ error: `ƒê∆°n h√†ng ch∆∞a ƒë·∫°t t·ªëi thi·ªÉu ${discount.minOrder.toLocaleString()}ƒë` });
    }

    // 6. √Åp d·ª•ng gi·∫£m gi√° v√† c·∫≠p nh·∫≠t Cart model
    const discountAmount = Math.round(currentSubtotal * (discount.discountPercent / 100));
    cart.discount = discountAmount;
    cart.subtotal = currentSubtotal; // C·∫≠p nh·∫≠t l·∫°i subtotal trong cart
    cart.total = currentSubtotal + cart.deliveryFee - discountAmount;
    cart.promoCode = promotionCode; // ‚úÖ L∆ØU promotionCode v√†o tr∆∞·ªùng promoCode c·ªßa Cart model

    await cart.save(); // L∆∞u c√°c thay ƒë·ªïi v√†o database

    // 7. Ghi nh·∫≠n ng∆∞·ªùi d√πng ƒë√£ d√πng m√£ trong UserDiscount
    await UserDiscount.updateOne(
      { userId, discountId: discount._id },
      { $set: { isUsed: true } },
      { upsert: true } // Upsert: n·∫øu ch∆∞a c√≥ th√¨ t·∫°o m·ªõi, n·∫øu c√≥ th√¨ c·∫≠p nh·∫≠t
    );

    // 8. Tr·∫£ v·ªÅ to√†n b·ªô th√¥ng tin gi·ªè h√†ng ƒë√£ c·∫≠p nh·∫≠t
    // ƒê√¢y l√† ph·∫ßn quan tr·ªçng nh·∫•t ƒë·ªÉ frontend kh√¥ng b·ªã NaN
    res.status(200).json({
      message: '√Åp d·ª•ng m√£ gi·∫£m gi√° th√†nh c√¥ng',
      items: currentCartItems, // Tr·∫£ v·ªÅ danh s√°ch items ƒë√£ ƒë∆∞·ª£c populate v√† x·ª≠ l√Ω
      subtotal: cart.subtotal,
      deliveryFee: cart.deliveryFee,
      discount: cart.discount, // S·ªë ti·ªÅn gi·∫£m gi√° th·ª±c t·∫ø ƒë√£ √°p d·ª•ng
      total: cart.total, // T·ªïng cu·ªëi c√πng sau gi·∫£m gi√°
      promoCode: cart.promoCode // ‚úÖ Tr·∫£ v·ªÅ promoCode ƒë√£ l∆∞u
    });
  } catch (err) {
    console.error('[Apply Discount]', err);
    // N·∫øu c√≥ l·ªói, ƒë·∫£m b·∫£o tr·∫£ v·ªÅ l·ªói t·ª´ backend ƒë·ªÉ frontend hi·ªÉn th·ªã
    res.status(500).json({ error: err.message || 'Kh√¥ng th·ªÉ √°p d·ª•ng m√£ gi·∫£m gi√°' });
  }
};

// update quantity
exports.updateCartItemQuantity = async (req, res) => {
  try {
    const userId = req.user._id;
    const { itemId } = req.params;
    const { quantity } = req.body;

    if (!quantity || quantity <= 0) {
      return res.status(400).json({ error: 'S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá' });
    }

    const cartItem = await CartItem.findOne({ _id: itemId, userId });
    if (!cartItem) {
      return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m trong gi·ªè h√†ng' });
    }

    cartItem.quantity = quantity;

    // C·∫≠p nh·∫≠t l·∫°i gi√° theo quantity m·ªõi
    const product = await Product.findById(cartItem.productId).populate('sizeOptions');
    if (!product) return res.status(404).json({ error: 'S·∫£n ph·∫©m kh√¥ng t·ªìn t·∫°i' });

    const sizeOption = product.sizeOptions.find(s => s.size === cartItem.size);
    if (!sizeOption || typeof sizeOption.multiplier !== 'number') {
      return res.status(400).json({ error: 'K√≠ch th∆∞·ªõc s·∫£n ph·∫©m kh√¥ng h·ª£p l·ªá' });
    }

    let newPrice = product.basePrice * sizeOption.multiplier * quantity;

    for (const toppingId of cartItem.toppings) {
      const topping = await Topping.findById(toppingId);
      if (topping && typeof topping.price === 'number') {
        newPrice += topping.price * quantity;
      }
    }

    cartItem.price = newPrice;
    await cartItem.save();

    // T√≠nh l·∫°i to√†n b·ªô gi·ªè h√†ng
    const cart = await Cart.findOne({ userId }).populate({
      path: 'cartItems',
      populate: [
        {
          path: 'productId',
          model: 'Product',
          populate: ['categoryId', { path: 'sizeOptions', model: 'Size' }, 'toppingOptions']
        },
        { path: 'toppings', model: 'Topping' }
      ]
    });

    if (!cart) return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y gi·ªè h√†ng' });

    let subtotal = 0;
    const updatedItems = cart.cartItems.map(item => {
      subtotal += item.price;
      return {
        _id: item._id,
        productId: item.productId,
        name: item.productId.name,
        size: item.size,
        toppings: item.toppings,
        quantity: item.quantity,
        price: item.price
      };
    });

    cart.subtotal = subtotal;

    // Gi·ªØ discount hi·ªán t·∫°i, nh∆∞ng ƒë·∫£m b·∫£o kh√¥ng v∆∞·ª£t qu√° subtotal
    if (cart.discount > subtotal) {
      cart.discount = 0;
      cart.promoCode = '';
    }

    cart.total = subtotal + cart.deliveryFee - cart.discount;
    await cart.save();

    res.status(200).json({
      message: 'C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng th√†nh c√¥ng',
      items: updatedItems,
      subtotal: cart.subtotal,
      deliveryFee: cart.deliveryFee,
      discount: cart.discount,
      total: cart.total,
      promoCode: cart.promoCode || ''
    });

  } catch (err) {
    console.error('[updateCartItemQuantity]', err);
    res.status(500).json({ error: 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng s·∫£n ph·∫©m' });
  }
};
